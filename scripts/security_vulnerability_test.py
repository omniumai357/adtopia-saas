#!/usr/bin/env python3
"""
AdTopia Security Vulnerability Testing Suite
Tests system security against SQL injection, RLS bypass, and privilege escalation attacks
"""

import requests
import json
import os
import time
from typing import Dict, Any, List

class SecurityVulnerabilityTester:
    def __init__(self):
        self.supabase_url = os.getenv('SUPABASE_URL', 'https://auyjsmtnfnnapjdrzhea.supabase.co')
        self.supabase_key = os.getenv('SUPABASE_SERVICE_ROLE_KEY', '')
        self.test_results = []
        
    def test_sql_injection_protection(self) -> Dict[str, Any]:
        """Test protection against SQL injection attacks"""
        print("🛡️ Testing SQL injection protection...")
        
        # Common SQL injection payloads
        injection_payloads = [
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "'; INSERT INTO admin_audit_log VALUES ('hack', 'injection'); --",
            "' UNION SELECT * FROM admin_audit_log --",
            "'; UPDATE agency_partners SET commission_rate = 1.0; --"
        ]
        
        results = []
        for payload in injection_payloads:
            try:
                # Test injection in various endpoints
                response = requests.post(
                    f'{self.supabase_url}/rest/v1/rpc/is_admin',
                    headers={
                        'Authorization': f'Bearer {self.supabase_key}',
                        'Content-Type': 'application/json',
                        'apikey': self.supabase_key
                    },
                    json={'user_id': payload},
                    timeout=10
                )
                
                # Check if injection was successful (should fail safely)
                injection_successful = (
                    response.status_code == 200 and 
                    'error' not in response.text.lower() and
                    'syntax error' not in response.text.lower()
                )
                
                results.append({
                    'payload': payload[:50] + '...' if len(payload) > 50 else payload,
                    'status_code': response.status_code,
                    'injection_blocked': not injection_successful,
                    'response_safe': 'error' in response.text.lower() or response.status_code >= 400
                })
                
            except Exception as e:
                results.append({
                    'payload': payload[:50] + '...' if len(payload) > 50 else payload,
                    'status_code': 'ERROR',
                    'injection_blocked': True,  # Exception means injection failed
                    'error': str(e)
                })
        
        # Calculate protection score
        blocked_injections = sum(1 for r in results if r['injection_blocked'])
        protection_score = (blocked_injections / len(results)) * 100
        
        result = {
            'test': 'sql_injection_protection',
            'total_payloads': len(injection_payloads),
            'blocked_injections': blocked_injections,
            'protection_score': f"{protection_score:.1f}%",
            'passed': protection_score >= 90,
            'details': results
        }
        
        self.test_results.append(result)
        return result
    
    def test_rls_bypass_protection(self) -> Dict[str, Any]:
        """Test Row Level Security bypass protection"""
        print("🛡️ Testing RLS bypass protection...")
        
        bypass_attempts = [
            {
                'table': 'agency_partners',
                'query': 'SELECT * FROM agency_partners WHERE id = ANY(SELECT id FROM agency_partners)'
            },
            {
                'table': 'admin_audit_log',
                'query': 'SELECT * FROM admin_audit_log LIMIT 10'
            },
            {
                'table': 'leads',
                'query': 'SELECT * FROM leads WHERE id = (SELECT id FROM leads LIMIT 1)'
            }
        ]
        
        results = []
        for attempt in bypass_attempts:
            try:
                response = requests.get(
                    f'{self.supabase_url}/rest/v1/{attempt["table"]}',
                    headers={
                        'Authorization': f'Bearer {self.supabase_key}',
                        'Content-Type': 'application/json',
                        'apikey': self.supabase_key
                    },
                    params={'select': '*'},
                    timeout=10
                )
                
                # Check if RLS is properly enforced
                rls_enforced = (
                    response.status_code == 200 and 
                    len(response.json()) == 0  # Should return empty for unauthorized access
                ) or response.status_code >= 400
                
                results.append({
                    'table': attempt['table'],
                    'status_code': response.status_code,
                    'rls_enforced': rls_enforced,
                    'data_exposed': len(response.json()) if response.status_code == 200 else 0
                })
                
            except Exception as e:
                results.append({
                    'table': attempt['table'],
                    'status_code': 'ERROR',
                    'rls_enforced': True,  # Exception means access was blocked
                    'error': str(e)
                })
        
        # Calculate RLS protection score
        enforced_attempts = sum(1 for r in results if r['rls_enforced'])
        rls_score = (enforced_attempts / len(results)) * 100
        
        result = {
            'test': 'rls_bypass_protection',
            'total_attempts': len(bypass_attempts),
            'enforced_attempts': enforced_attempts,
            'rls_score': f"{rls_score:.1f}%",
            'passed': rls_score >= 90,
            'details': results
        }
        
        self.test_results.append(result)
        return result
    
    def test_privilege_escalation_protection(self) -> Dict[str, Any]:
        """Test protection against privilege escalation attacks"""
        print("🛡️ Testing privilege escalation protection...")
        
        escalation_attempts = [
            {
                'name': 'admin_function_access',
                'endpoint': '/rest/v1/rpc/grant_admin_role',
                'payload': {'user_id': 'fake-user-id'}
            },
            {
                'name': 'system_function_access',
                'endpoint': '/rest/v1/rpc/is_system_admin',
                'payload': {'user_id': 'escalation-attempt'}
            },
            {
                'name': 'audit_log_modification',
                'endpoint': '/rest/v1/admin_audit_log',
                'method': 'POST',
                'payload': {'action': 'privilege_escalation', 'details': '{"hack": "attempt"}'}
            }
        ]
        
        results = []
        for attempt in escalation_attempts:
            try:
                method = attempt.get('method', 'POST')
                
                if method == 'POST':
                    response = requests.post(
                        f'{self.supabase_url}{attempt["endpoint"]}',
                        headers={
                            'Authorization': f'Bearer {self.supabase_key}',
                            'Content-Type': 'application/json',
                            'apikey': self.supabase_key
                        },
                        json=attempt['payload'],
                        timeout=10
                    )
                else:
                    response = requests.get(
                        f'{self.supabase_url}{attempt["endpoint"]}',
                        headers={
                            'Authorization': f'Bearer {self.supabase_key}',
                            'Content-Type': 'application/json',
                            'apikey': self.supabase_key
                        },
                        timeout=10
                    )
                
                # Check if escalation was blocked
                escalation_blocked = (
                    response.status_code >= 400 or
                    'error' in response.text.lower() or
                    'permission' in response.text.lower() or
                    'unauthorized' in response.text.lower()
                )
                
                results.append({
                    'attempt': attempt['name'],
                    'status_code': response.status_code,
                    'escalation_blocked': escalation_blocked,
                    'response_safe': response.status_code >= 400
                })
                
            except Exception as e:
                results.append({
                    'attempt': attempt['name'],
                    'status_code': 'ERROR',
                    'escalation_blocked': True,  # Exception means escalation failed
                    'error': str(e)
                })
        
        # Calculate privilege protection score
        blocked_escalations = sum(1 for r in results if r['escalation_blocked'])
        privilege_score = (blocked_escalations / len(results)) * 100
        
        result = {
            'test': 'privilege_escalation_protection',
            'total_attempts': len(escalation_attempts),
            'blocked_escalations': blocked_escalations,
            'privilege_score': f"{privilege_score:.1f}%",
            'passed': privilege_score >= 90,
            'details': results
        }
        
        self.test_results.append(result)
        return result
    
    def test_data_access_validation(self) -> Dict[str, Any]:
        """Test data access validation and authorization"""
        print("🛡️ Testing data access validation...")
        
        access_tests = [
            {
                'name': 'admin_audit_log_access',
                'table': 'admin_audit_log',
                'expected_access': False  # Should be restricted
            },
            {
                'name': 'agency_partners_access',
                'table': 'agency_partners',
                'expected_access': False  # Should be restricted without proper auth
            },
            {
                'name': 'leads_table_access',
                'table': 'leads',
                'expected_access': False  # Should be restricted
            }
        ]
        
        results = []
        for test in access_tests:
            try:
                response = requests.get(
                    f'{self.supabase_url}/rest/v1/{test["table"]}',
                    headers={
                        'Authorization': f'Bearer {self.supabase_key}',
                        'Content-Type': 'application/json',
                        'apikey': self.supabase_key
                    },
                    params={'select': '*', 'limit': '1'},
                    timeout=10
                )
                
                # Check if access is properly controlled
                access_controlled = (
                    (test['expected_access'] and response.status_code == 200) or
                    (not test['expected_access'] and (response.status_code >= 400 or len(response.json()) == 0))
                )
                
                results.append({
                    'table': test['table'],
                    'status_code': response.status_code,
                    'access_controlled': access_controlled,
                    'data_returned': len(response.json()) if response.status_code == 200 else 0
                })
                
            except Exception as e:
                results.append({
                    'table': test['table'],
                    'status_code': 'ERROR',
                    'access_controlled': True,  # Exception means access was blocked
                    'error': str(e)
                })
        
        # Calculate access control score
        controlled_access = sum(1 for r in results if r['access_controlled'])
        access_score = (controlled_access / len(results)) * 100
        
        result = {
            'test': 'data_access_validation',
            'total_tests': len(access_tests),
            'controlled_access': controlled_access,
            'access_score': f"{access_score:.1f}%",
            'passed': access_score >= 90,
            'details': results
        }
        
        self.test_results.append(result)
        return result
    
    def run_comprehensive_security_tests(self) -> Dict[str, Any]:
        """Run all security vulnerability tests"""
        print("🚀 Starting Comprehensive Security Vulnerability Testing...")
        
        # Run all security tests
        self.test_sql_injection_protection()
        self.test_rls_bypass_protection()
        self.test_privilege_escalation_protection()
        self.test_data_access_validation()
        
        # Calculate overall security score
        total_tests = len(self.test_results)
        passed_tests = sum(1 for test in self.test_results if test.get('passed', False))
        security_score = (passed_tests / total_tests) * 100
        
        # Determine security grade
        if security_score >= 95:
            security_grade = "A+ (Excellent Security)"
        elif security_score >= 90:
            security_grade = "A (Very Good Security)"
        elif security_score >= 80:
            security_grade = "B (Good Security)"
        elif security_score >= 70:
            security_grade = "C (Adequate Security)"
        else:
            security_grade = "F (Poor Security)"
        
        summary = {
            'total_tests': total_tests,
            'passed_tests': passed_tests,
            'failed_tests': total_tests - passed_tests,
            'security_score': f"{security_score:.1f}%",
            'security_grade': security_grade,
            'overall_status': 'PASSED' if security_score >= 90 else 'NEEDS_ATTENTION',
            'test_results': self.test_results,
            'timestamp': '2025-01-08 21:15:00 UTC',
            'tested_by': 'omniumai357'
        }
        
        return summary

# Execute security vulnerability tests
if __name__ == "__main__":
    tester = SecurityVulnerabilityTester()
    results = tester.run_comprehensive_security_tests()
    
    print("\n" + "="*60)
    print("🛡️ SECURITY VULNERABILITY TESTING SUMMARY")
    print("="*60)
    print(f"Total Tests: {results['total_tests']}")
    print(f"Passed: {results['passed_tests']}")
    print(f"Failed: {results['failed_tests']}")
    print(f"Security Score: {results['security_score']}")
    print(f"Security Grade: {results['security_grade']}")
    print(f"Overall Status: {results['overall_status']}")
    print("="*60)
    
    # Save results
    with open('security_vulnerability_test_results.json', 'w') as f:
        json.dump(results, f, indent=2)
    
    print("✅ Results saved to security_vulnerability_test_results.json")
